{
  "hash": "0884475531a5d2b29c33168fde3ba624",
  "result": {
    "markdown": "---\ntitle: \"Raking to Improve Survey Weights\"\ndescription: \"Employing raking, also known as iterative proportional fitting, to refine survey weights and better align results with known population values.\"\nauthor: \n  - name: Lewis White\n    url: https://lewis-r-white.github.io/\n    affiliation: Columbia University, Mailman School of Public Health\ndate: 05-03-2024\ncategories: [Columbia University, R, Survey]\ncitation:\n  url: https://lewis-r-white.github.io/posts/2024-05-03-survey-raking/\neditor: visual\nimage: survey_image.jpg\ndraft: false \nformat:\n  html:\n    code-fold: true\n---\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Introduction: The Need for Survey Weights\n\nSurveys are an essential tool for gathering information and understanding public opinion on various issues. The success of survey-based research largely depends on the sampling procedure used. When sampling units do not have equal probabilities of selection, survey weights become crucial to ensure that statistics derived from the sample accurately represent the target population.\n\nTypically, a survey weight for each unit is calculated as the inverse of its probability of being selected. In a simple random sample, this would be 1/N, where N is the total population size, making the weight uniform across all units. However, more complex survey designs—such as stratified, clustered, or multistage sampling—require different weights since each unit may represent varying numbers of people from the target population.\n\nEven with accurately calculated initial weights, the sample might not perfectly reflect the population due to the inherent randomness of sampling, or factors like non-response or coverage biases. To address these discrepancies, sample weights can be adjusted to better align with known population totals. This process, known as sample balancing, will be further explored with a focus on a specific technique called 'raking' in the next section.\n\n# An Overview of the Raking Methodology for Survey Weights\n\nRaking, also known as iterative proportional fitting, is a post stratification procedure that can be used to adjust survey weights to better align with known population totals. It is most commonly used to account for non-response and non-coverage biases, but can account for a range of biases in the design and implementation of a survey. Raking enhances the representativeness and accuracy of survey results, assuming accurate population totals.\n\nHere are some commonly recommended ‘best practices’ for raking:\n\n**Base weights:**\n\n-   Starting with base weights, initial weights based on the inverse probability of selection, is a standard approach (Battaglia et al., 2009).\n\n**Variable selection:**\n\n-   Choosing relevant variables is critical. Typically, these include demographic information and key survey topics. For instance, political affiliation might be used for a survey on public policy opinions (Pew Research Center, 2018).\n\n**Collapse small cells:**\n\n-   It is recommended to merge smaller categories that represent less than 2% of the sample or control totals to prevent issues with convergence and prevent overfitting (Battaglia et al., 2009)(Oh and Scheuren, 1978).\n\n**Weight trimming:**\n\n-   Limiting the number of iterations and trimming outlier weights helps prevent overfitting. Weights significantly larger than average (e.g. 5x) should be truncated to maintain balance (Battaglia et al., 2004)\n\n**Model evaluation:**\n\n-   Often, demographic discrepancies exceeding 5 percentage points are “notable” and discrepancies less than 2 percentage points are not. Discrepancies in the 2 to 5 point range may be notable if the characteristic is of special interest for the study or is strongly associated with key outcome variables (Debell & Krosnick, 2009)\n\n-   It's best to examine the effects of raking on variables not used as raking factors. If these estimates show a greater difference from the benchmarks using the new weights, consider raking with a revised poststratification approach (Debell & Krosnick, 2009)\n\nThe following section will outline the raking algorithm and walk through a simple demonstration of how the raking process can be used to improve alignment with known population values.\n\n# Simple Raking Example\n\nThis section provides a high level description of the raking algorithm and then walks through a simple example using two binary variables to illustrate the raking process.\n\n## Raking steps:\n\n1.  Take each row in turn and multiply each entry in the row by the ratio of the population total to the weighted sample total for that category\n    -   The row totals of the adjusted data should agree with the population totals for that variable. The weighted column totals of the adjusted data, however, may not yet agree with the population totals for the column variable.\n2.  Take each column and multiply each entry in the column by the ratio of the population total to the current total for that category.\n    -   Now the weighted column totals of the adjusted data agree with the population totals for that variable, but the new weighted row totals may no longer match the corresponding population totals.\n3.  Continue alternating between the rows and the columns.\n    -   Close agreement on both rows and columns is usually achieved after a small number of iterations.\n4.  The result is a tabulation for the population that reflects the relation of the two control variables in the sample.\n5.  Raking can also adjust a set of data to control totals on three or more variables. In such situations the control totals often involve single variables, but they may involve two or more variables.\n\n## Simple Raking Example\n\n|                  | Child | Adult | Row Total |\n|------------------|-------|-------|-----------|\n| **Urban**        | 30    | 20    | 50        |\n| **Rural**        | 20    | 30    | 50        |\n| **Column Total** | 50    | 50    | 100       |\n\n**Desired population totals:**\n\n-   Urban: 60, Rural: 40\n\n-   Child: 40, Adult: 60\\\n\n**Adjusting the rows first to match the locality population totals:**\n\n-   Urban adjustment ratio: 60 / 50 = 1.2\n\n-   Rural adjustment ratio: 40 / 50 = 0.8\n\n**Adjusted rows:**\n\n|                  | Child | Adult | Row Total |\n|------------------|-------|-------|-----------|\n| **Urban**        | 36    | 24    | 60        |\n| **Rural**        | 16    | 24    | 40        |\n| **Column Total** | 52    | 48    | 100       |\n\nNow, the row totals match the population totals for locality. However, the column totals for age groups are still off.\n\n**Adjusting columns to match the age group population totals:**\n\n-   Child adjustment ratio: 40 / 52 ≈ 0.7692\n\n-   Adult adjustment ratio: 60 / 48 = 1.25\n\n**Adjusted columns:**\n\n|                  | Child | Adult | Row Total |\n|------------------|-------|-------|-----------|\n| **Urban**        | 27.69 | 30    | 57.69     |\n| **Rural**        | 12.31 | 30    | 42.31     |\n| **Column Total** | 40    | 60    | 100       |\n\n \n\n**Readjusting the rows to match the locality population totals:**\n\n-   Urban adjustment ratio: 60 / 57.69 = 1.04\n\n-   Rural adjustment ratio: 40 / 42.31 = 0.945\n\n**Adjusted rows:**\n\n|                  | Child | Adult | Row Total |\n|------------------|-------|-------|-----------|\n| **Urban**        | 28.80 | 31.20 | 60        |\n| **Rural**        | 11.61 | 28.36 | 40        |\n| **Column Total** | 40.44 | 59.56 | 100       |\n\n**Readjusting the columns to match the age population totals:**\n\n-   Child adjustment ratio: 40 / 40.44 = 0.989\n\n-   Adult adjustment ratio: 60 / 59.56 = 1.007\n\n|                  |           |           |               |\n|------------------|-----------|-----------|---------------|\n|                  | **Child** | **Adult** | **Row Total** |\n| **Urban**        | 28.49     | 31.43     | 59.92         |\n| **Rural**        | 11.51     | 28.57     | 40.08         |\n| **Column Total** | 40        | 60        | 100           |\n\nAt a certain point, the algorithm determines that the marginal populations are “close enough” to the target population — this is convergence. You are able to specify the convergence criterion when setting up the raking procedure. One simple definition of convergence requires that each marginal total of the raked weights be within a specified tolerance of the corresponding control total. In the rake() function in R, convergence is reached if the maximum change in a table entry is less than epsilon (default = 1).\n\nIt is harder to visualize when raking on more variables, but the process is the same. You continue making adjustments until the marginal sample populations are “close enough” to the target.\n\n# Case Study: Raking to Improve Representativeness in National Household Survey\n\n## Background:\n\nAs part of the Combating Household Air Pollution (CHAP) project, we applied raking to a national household survey on fuel use in Ghana. The CHAP project is a collaborative effort from several research institutions: Columbia University, UC Santa Barbara, and the Kintampo Health Research Center in Ghana. For the fuel survey, we also partnered with the Ghana Statistical Service to conduct the sampling and interviews.\n\nThe CHAP survey employed a multistage, cluster approach to the sample. A total of 370 enumeration areas (EAs) and 20 households within each EA were sampled for a total sample size of 7,400 households. Ghana’s 16 regions were used for stratification, as well as the classification of an EA as either urban or rural.\n\nInitial survey weights were calculated based on the probability of selecting an EA and a household within it. Discrepancies between our survey results and the census data from the Ghana Statistical Services (GSS) prompted us to employ raking to refine our weights.\n\n## Set Up:\n\nWe tested various raking models using the survey package in R, starting with base weights and adjusting for different sets of variables. To address issues with small cell sizes, regional data was consolidated into larger groupings. The process and rationale for these adjustments are detailed below.\n\n| Stat                            | Rake 1 | Rake 2 | Rake 3 | Rake 4 |\n|---------------------------------|--------|--------|--------|--------|\n| Total urban/rural households    | y      | y\\*    | y      | y\\*    |\n| Total households in each region | y      | y\\*    | y      | y      |\n| Regional urban/rural households |        | y      |        | y      |\n| Total primary fuel source       |        |        | y      | y\\*    |\n| Regional primary fuel source    |        |        |        | y      |\n\n: y\\* indicates that the measurement is obtained through the regional cross distribution.\n\nExpand the code blocks below to examine how we set up the raking procedure and complete raking for each of these models.\n\n### Setting up the Population Totals for Raking\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### urban/rural total\npop.urban_rural_str <-\n  data.frame(\n    urban_rural_str = c(\"urban\", \"rural\"),\n    Freq = c(\n      subset(gss, region == \"Total\")$hh_pop_urban,\n      subset(gss, region == \"Total\")$hh_pop_rural\n    )\n  )\n\n### primary fuel categories \n\nhh_pop_tot <- subset(gss, region == \"Total\")$hh_pop\n\nfrac_lpg <- subset(gss, region == \"Total\")$fuel_lpg / subset(gss, region == \"Total\")$hh_pop_fuel\n\nfrac_char <- subset(gss, region == \"Total\")$fuel_char / subset(gss, region == \"Total\")$hh_pop_fuel\n\nfrac_wood <- subset(gss, region == \"Total\")$fuel_wood / subset(gss, region == \"Total\")$hh_pop_fuel\n  \n\npop.primary_fuel <-\n  data.frame(\n    collapsed_fuel = c(\"none_other\", \"wood\", \"LPG\", \"charcoal\"),\n    Freq = c(\n      round((1 - (frac_lpg + frac_wood + frac_char)) * hh_pop_tot, 0),\n      round(frac_wood * hh_pop_tot, 0),\n      round(frac_lpg * hh_pop_tot, 0),\n      round(frac_char * hh_pop_tot, 0)\n    )\n  )\n\n\n### regional 2021 HH populations \ngss_regional <- filter(gss, region != \"Total\") \n\npop.region_hh <- data.frame(\n  region = gss_regional$region,\n  Freq = gss_regional$hh_pop\n)\n\n\n\n\n# regional main fuel \n#specify known main fuel population values for each of the regions \npop.region_main_fuel <- gss_regional %>% \n  mutate(none_other = fuel_none + fuel_other) %>%\n  rename(LPG = fuel_lpg, \n         wood = fuel_wood, \n         charcoal = fuel_char) %>%\n  select(region, none_other, wood, LPG, charcoal) %>%\n  \n  #apply scaling factor so population matches GSS total value\n  mutate(none_other = round(none_other * subset(gss, region == \"Total\")$hh_pop/subset(gss, region == \"Total\")$hh_pop_fuel, 0),\n         LPG = round(LPG * subset(gss, region == \"Total\")$hh_pop/subset(gss, region == \"Total\")$hh_pop_fuel,0),\n         wood = round(wood * subset(gss, region == \"Total\")$hh_pop/subset(gss, region == \"Total\")$hh_pop_fuel, 0),\n         charcoal = round(charcoal * subset(gss, region == \"Total\")$hh_pop/subset(gss, region == \"Total\")$hh_pop_fuel, 0))\n\nnorthern <- pop.region_main_fuel %>%\n  filter(region %in% c(\"Upper East\", \"Upper West\", \"North East\", \"Northern\", \"Savannah\", \"Oti\", \"Bono\", \"Bono East\", \"Ahafo\")) %>%\n  summarise(\n    region = \"northern\",\n    none_other = sum(none_other),\n    wood = sum(wood),\n    LPG = sum(LPG),\n    charcoal = sum(charcoal)\n  )\n\n\nmiddle <- pop.region_main_fuel %>%\n  filter(region %in% c(\"Ashanti\", \"Eastern\")) %>%\n  summarise(\n    region = \"middle\",\n    none_other = sum(none_other),\n    wood = sum(wood),\n    LPG = sum(LPG),\n    charcoal = sum(charcoal)\n  )\n\nsoutheast <- pop.region_main_fuel %>%\n  filter(region %in% c(\"Greater Accra\", \"Volta\")) %>%\n  summarise(\n    region = \"southeast\",\n    none_other = sum(none_other),\n    wood = sum(wood),\n    LPG = sum(LPG),\n    charcoal = sum(charcoal)\n  )\n\nsouthwest <- pop.region_main_fuel %>%\n  filter(region %in% c(\"Central\", \"Western\", \"Western North\")) %>%\n  summarise(\n    region = \"southwest\",\n    none_other = sum(none_other),\n    wood = sum(wood),\n    LPG = sum(LPG),\n    charcoal = sum(charcoal)\n  )\n\ncollapsed_region_primary_fuel <- bind_rows(northern, middle, southeast, southwest)\n\n\n#Combine primary fuel with each row specifying which is applicable \npop_region_primary_fuel_long <- collapsed_region_primary_fuel %>%\n  pivot_longer(cols = c(none_other, wood, LPG, charcoal), names_to = \"collapsed_fuel\", values_to = \"Count\") #names need to match what is in the survey!!\n\n# reformat this data so each row is a household (necessary for creating pop.table below)\npop_region_primary_fuel_long <- pop_region_primary_fuel_long %>%\n  uncount(Count) %>%\n  rename(collapsed_region = region)\n\n#create table of LPG main stove by collapsed regions\npop.table_primary_fuel <- xtabs(~collapsed_region+collapsed_fuel, pop_region_primary_fuel_long)\n\n\n\n\n# regional urbanicity \n#regional 2021 HH populations \npop.region_urban_rural_hh <- gss_regional %>%\n  select(region, hh_pop_rural, hh_pop_urban) %>%\n  rename(rural = hh_pop_rural, \n         urban = hh_pop_urban)\n\n\nnorthern <- pop.region_urban_rural_hh %>%\n  filter(region %in% c(\"Upper East\", \"Upper West\", \"North East\", \"Northern\", \"Savannah\", \"Oti\", \"Bono\", \"Bono East\", \"Ahafo\")) %>%\n  summarise(\n    region = \"northern\",\n    urban = sum(urban),\n    rural = sum(rural)\n  )\n\n\nmiddle <- pop.region_urban_rural_hh %>%\n  filter(region %in% c(\"Ashanti\", \"Eastern\")) %>%\n  summarise(\n    region = \"middle\",\n    urban = sum(urban),\n    rural = sum(rural)\n  )\n\nsoutheast <- pop.region_urban_rural_hh %>%\n  filter(region %in% c(\"Greater Accra\", \"Volta\")) %>%\n  summarise(\n    region = \"southeast\",\n    urban = sum(urban),\n    rural = sum(rural)\n  )\n\nsouthwest <- pop.region_urban_rural_hh %>%\n  filter(region %in% c(\"Central\", \"Western\", \"Western North\")) %>%\n  summarise(\n    region = \"southwest\",\n    urban = sum(urban),\n    rural = sum(rural)\n  )\n\ncollapsed_region_urban_rural_hh <- bind_rows(northern, middle, southeast, southwest)\n\n\n#Combine LPG yes/no columns with each row specifying which is applicable \npop_region_urban_rural_long <- collapsed_region_urban_rural_hh %>%\n  pivot_longer(cols = c(rural, urban), names_to = \"urban_rural_str\", values_to = \"Count\") #names need to match what is in the survey!!\n\n# reformat this data so each row is a household (necessary for creating pop.table below)\npop_region_urban_rural_long <- pop_region_urban_rural_long %>%\n  uncount(Count) %>%\n  rename(collapsed_region = region)\n\n#create table of LPG main stove by collapsed regions\npop.table_urban_rural <- xtabs(~collapsed_region+urban_rural_str, pop_region_urban_rural_long)\n```\n:::\n\n\n### Specifying the Survey Design (using `Rake()`) for Each of the Models\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Un-weighted\nunweighted_survey_design <- svydesign(id=~eacode, #specify clusters\n                           strata= ~region, #specify the region strata\n                           data=full_survey_collapsed)\n\n#base weights\nsurvey_design <- svydesign(id=~eacode, #specify clusters\n                           weights= ~weight, #specify the survey weights\n                           strata= ~region, #specify the region strata\n                           data=full_survey_collapsed)\n\n\n# Rake 1\nraked_surv <- rake(survey_design, \n                   list(~urban_rural_str, ~region), \n                   list(pop.urban_rural_str, pop.region_hh)\n                   )\n\nupper_weight <- mean(weights(raked_surv, type = \"sampling\")) * 5\n\nrake1_design <- trimWeights(raked_surv, lower=0.1, upper=upper_weight,\n                                   strict = TRUE)\n\n\n#Rake 2\nraked_surv <- rake(survey_design, \n                   list(~urban_rural_str+collapsed_region), \n                   list(pop.table_urban_rural)\n                   )\n\nupper_weight <- mean(weights(raked_surv, type = \"sampling\")) * 5\n\nrake2_design <- trimWeights(raked_surv, lower=0.1, upper=upper_weight,\n                                   strict = TRUE)\n\n\n#Rake 3\nraked_surv <- rake(survey_design, list(~urban_rural_str, ~collapsed_fuel, ~region), list(pop.urban_rural_str, pop.primary_fuel, pop.region_hh), control = list(maxit = 20, epsilon = 1, verbose = FALSE))\n\nupper_weight <- mean(weights(raked_surv, type = \"sampling\")) * 5\n\nrake3_design <- trimWeights(raked_surv, lower=0.1, upper=upper_weight,\n                                   strict = TRUE)\n\n\n#Rake 4\nraked_surv <- rake(survey_design, \n                   list(~urban_rural_str+collapsed_region, ~collapsed_region+collapsed_fuel), \n                   list(pop.table_urban_rural, pop.table_primary_fuel), control = list(maxit = 15, epsilon = 1))\n\nupper_weight <- mean(weights(raked_surv, type = \"sampling\")) * 5\n\nrake4_design <- trimWeights(raked_surv, lower=0.1, upper=upper_weight,\n                                   strict = TRUE)\n```\n:::\n\n\n### Calculating the Survey Statistics for Each Model\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunweighted <- calculate_survey_stats(unweighted_survey_design, \"unweighted\")\n\nGL_FM <- calculate_survey_stats(survey_design, \"GL_FM\")\n\nrake1 <- calculate_survey_stats(rake1_design, \"rake1\")\n\nrake2 <- calculate_survey_stats(rake2_design, \"rake2\")\n\nrake3 <- calculate_survey_stats(rake3_design, \"rake3\")\n\nrake4 <- calculate_survey_stats(rake4_design, \"rake4\")\n```\n:::\n\n\n## Results\n\nThe effectiveness of each raking model was evaluated by comparing survey results against GSS census data for included variables. Highlighted cells indicate a difference of at least 5 % between the given cell value and the GSS-2021 value. Raking generally enhanced the alignment with GSS values, particularly for variables directly adjusted in the models. The table below outlines the performance metrics across different models.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhigh_level_results <- left_join(GSS_stats, unweighted) %>%\n  left_join(GL_FM) %>%\n  left_join(rake1) %>%\n  left_join(rake2) %>%\n  left_join(rake3) %>%\n  left_join(rake4) %>%\n  mutate(rake1 = as.numeric(rake1),\n         rake2 = as.numeric(rake2),\n         rake3 = as.numeric(rake3),\n         rake4 = as.numeric(rake4)) %>%\n  filter(stat != \"total_households\")\n\n\n#create shaded table of high level results\n\n# Round GSS values to two decimal places\nhigh_level_results$GSS <- round(high_level_results$GSS, 2)\n\n# Calculate bounds with different methods for the first three rows and the rest\nhigh_level_results$lower_bound <- ifelse(1:nrow(high_level_results) <= 3, high_level_results$GSS * 0.95, high_level_results$GSS - 5)\n\nhigh_level_results$upper_bound <- ifelse(1:nrow(high_level_results) <= 3, high_level_results$GSS * 1.05, high_level_results$GSS + 5)\n\n# Create the datatable with custom JS for highlighting and hide lower and upper bound columns\ndatatable(high_level_results, options = list(\n  rowCallback = JS(\"\n    function(row, data) {\n      for (var i = 2; i < data.length-2; i++) {\n        var lowerBound = parseFloat(data[data.length-2]);\n        var upperBound = parseFloat(data[data.length-1]);\n        var cellValue = parseFloat(data[i]);\n        if (cellValue < lowerBound || cellValue > upperBound) {\n          $('td:eq('+i+')', row).css('background-color', '#ff9999');\n        }\n      }\n    }\"\n  ),\n  columnDefs = list(list(visible = FALSE, targets = c(ncol(high_level_results)-1, ncol(high_level_results))))\n))\n```\n\n::: {.cell-output-display}\n```{=html}\n<div class=\"datatables html-widget html-fill-item-overflow-hidden html-fill-item\" id=\"htmlwidget-8ec2761fff0188c3db59\" style=\"width:100%;height:auto;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-8ec2761fff0188c3db59\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"data\":[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\"],[\"hh_size\",\"hh_size_rural\",\"hh_size_urban\",\"pct_rural\",\"pct_LPG\",\"pct_CW\",\"pct_LPG_urban\",\"pct_LPG_rural\",\"pct_borehole\",\"pct_sachet\",\"pct_pipe_tap\",\"pct_rooms_two_plus\",\"pct_sleeping_rooms_two_plus\",\"pct_separate_cooking\",\"pct_electric_light\"],[3.6,4,3.3,39.33,36.93,54.3,51.27,14.83,17.69,37.44,31.71,51.67,36.66,47.73,86.31],[\"4.19\",\"4.48\",\"3.88\",\"52.10\",\"19.62\",\"76.25\",\"32.81\",\"7.51\",\"25.12\",\"29.35\",\"33.87\",\"79.51\",\"33.59\",\"49.29\",\"81.04\"],[\"3.79\",\"4.14\",\"3.62\",\"32.89\",\"32.47\",\"63.83\",\"42.77\",\"11.47\",\"12.60\",\"43.68\",\"35.91\",\"75.98\",\"31.40\",\"49.81\",\"88.26\"],[3.84,4.19,3.61,39.39,30.35,66.05,42.71,11.33,14.88,42.21,34.66,76.45999999999999,31.22,50.01,86.67],[3.84,4.14,3.65,39.22,29.85,66.61,41.82,11.3,14.7,41.55,35.16,75.98,31.1,50.12,86.67],[3.78,4.19,3.5,39.7,36.66,55.02,51.9,13.51,15.36,42.65,33.56,76.27,30.75,51.22,86.41],[3.78,4.11,3.56,39.58,36.91,55.59,51.98,13.91,15.11,42.04,34.04,75.81,30.71,51.57,86.55],[3.42,3.8,3.135,34.33,31.93,49.3,46.27,9.83,12.69,32.44,26.71,46.67,31.66,42.73,81.31],[3.78,4.2,3.465,44.33,41.93,59.3,56.27,19.83,22.69,42.44,36.71,56.67,41.66,52.73,91.31]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th> <\\/th>\\n      <th>stat<\\/th>\\n      <th>GSS<\\/th>\\n      <th>unweighted<\\/th>\\n      <th>GL_FM<\\/th>\\n      <th>rake1<\\/th>\\n      <th>rake2<\\/th>\\n      <th>rake3<\\/th>\\n      <th>rake4<\\/th>\\n      <th>lower_bound<\\/th>\\n      <th>upper_bound<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"rowCallback\":\"\\n    function(row, data) {\\n      for (var i = 2; i < data.length-2; i++) {\\n        var lowerBound = parseFloat(data[data.length-2]);\\n        var upperBound = parseFloat(data[data.length-1]);\\n        var cellValue = parseFloat(data[i]);\\n        if (cellValue < lowerBound || cellValue > upperBound) {\\n          $('td:eq('+i+')', row).css('background-color', '#ff9999');\\n        }\\n      }\\n    }\",\"columnDefs\":[{\"visible\":false,\"targets\":[9,10]},{\"className\":\"dt-right\",\"targets\":[2,5,6,7,8,9,10]},{\"orderable\":false,\"targets\":0}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false}},\"evals\":[\"options.rowCallback\"],\"jsHooks\":[]}</script>\n```\n:::\n:::\n\n\n## Conclusions\n\nAs expected, we found that the raking process consistently improved alignment with GSS values for raked variables. For statistics where the variable was not included in the raking process, we found the results sometimes better aligned post-raking and never became concerningly worse.\n\nAs the statistics for variables not used in the raking process tended to remain stable or improved slightly in the version of our raking model that utilized the most information in the set up (rake 4), we decided to move ahead with that model. Additional sensitivity analysis was conducted to examine the stability of the results when using different regional groupings.\n\n## Sensitivity Analysis: Grouping Variations\n\nWe explored different regional groupings to ensure robust model performance without convergence issues. Grouping strategies were informed by demographic similarities and household population sizes, ensuring meaningful comparisons and reliable raking results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = regions, aes(fill = region)) +\n  theme_minimal() +\n  labs(fill = \"Region\",\n       title = \"Regions of Ghana\")+\n  theme(plot.title = element_text(size = 20)) +\n  theme(\n    axis.text = element_blank(),  # Remove axis text\n    axis.title = element_blank(),  # Remove axis titles\n    panel.grid = element_blank()\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/Maps-1.png){width=672}\n:::\n\n```{.r .cell-code}\nrake1_regions <- regions %>%\n  mutate(collapsed_region = case_when(\n  region %in% c(\"Ashanti\", \"Eastern\") ~ \"middle\",\n  region %in% c(\"Upper East\", \"Upper West\", \"Northern East\", \"Northern\", \"Savannah\", \"Oti\", \"Bono\", \"Bono East\", \"Ahafo\") ~ \"northern\",\n  region %in% c(\"Greater Accra\", \"Volta\") ~ \"southeast\",\n  region %in% c(\"Central\", \"Western\", \"Western North\") ~ \"southwest\",\n  TRUE ~ region)) %>%\n  mutate(collapsed_region = factor(collapsed_region, levels = c(\"northern\", \"middle\", \"southeast\", \"southwest\")))\n\n# Define custom colors for each region\ncustom_colors <- c(\"middle\" = \"#2b8f6d\", \n                   \"northern\" = \"#58b368\", \n                   \"southeast\" = \"#bcba50\", \n                   \"southwest\" = \"#EFEEB4\"\n                   )\n\nggplot() +\n  geom_sf(data = rake1_regions, aes(fill = collapsed_region)) +\n  scale_fill_manual(values = custom_colors) +\n  theme_minimal() +\n  labs(fill = \"Region\",\n       title = \"Rake 4a Collapsed Regions\") +\n  theme(plot.title = element_text(size = 20)) +\n  theme(\n    axis.text = element_blank(),  # Remove axis text\n    axis.title = element_blank(),  # Remove axis titles\n    panel.grid = element_blank()\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/Maps-2.png){width=672}\n:::\n\n```{.r .cell-code}\nrake2_regions <- regions %>%\n  mutate(collapsed_region = case_when(\n  region %in% c(\"Ashanti\", \"Eastern\") ~ \"middle\",\n  region %in% c(\"Upper East\", \"Upper West\", \"Northern East\", \"Northern\", \"Savannah\", \"Oti\", \"Western North\", \"Bono\", \"Bono East\", \"Ahafo\") ~ \"northern\",\n  region %in% c(\"Greater Accra\", \"Volta\", \"Central\", \"Western\") ~ \"coastal\",\n  TRUE ~ region)) %>%\n  mutate(collapsed_region = factor(collapsed_region, levels = c(\"northern\", \"middle\", \"coastal\")))\n\n# Define custom colors for each region\ncustom_colors <- c(\"middle\" = \"#2b8f6d\", \n                   \"northern\" = \"#58b368\", \n                   \"coastal\" = \"#EFEEB4\"\n                   )\n\nggplot() +\n  geom_sf(data = rake2_regions, aes(fill = collapsed_region)) +\n  scale_fill_manual(values = custom_colors) +\n  theme_minimal() +\n  labs(fill = \"Region\",\n       title = \"Rake 4b Collapsed Regions\") +\n  theme(plot.title = element_text(size = 20)) +\n  theme(\n    axis.text = element_blank(),  # Remove axis text\n    axis.title = element_blank(),  # Remove axis titles\n    panel.grid = element_blank()\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/Maps-3.png){width=672}\n:::\n\n```{.r .cell-code}\nrake3_regions <- regions %>%\n  mutate(collapsed_region = case_when(\n  region %in% c(\"Ashanti\", \"Eastern\", \"Volta\") ~ \"middle\",\n  region %in% c(\"Upper East\", \"Upper West\", \"Northern East\", \"Northern\", \"Savannah\", \"Oti\", \"Western North\", \"Bono\", \"Bono East\", \"Ahafo\") ~ \"northern\",\n  region %in% c(\"Greater Accra\", \"Central\", \"Western\") ~ \"coastal\",\n  TRUE ~ region)) %>%\n  mutate(collapsed_region = factor(collapsed_region, levels = c(\"northern\", \"middle\", \"coastal\")))\n\n# Define custom colors for each region\ncustom_colors <- c(\"middle\" = \"#2b8f6d\", \n                   \"northern\" = \"#58b368\", \n                   \"coastal\" = \"#EFEEB4\"\n                   )\n\nggplot() +\n  geom_sf(data = rake3_regions, aes(fill = collapsed_region)) +\n  scale_fill_manual(values = custom_colors) +\n  theme_minimal() +\n  labs(fill = \"Region\",\n       title = \"Rake 4c Collapsed Regions\") +\n  theme(plot.title = element_text(size = 20)) +\n  theme(\n    axis.text = element_blank(),  # Remove axis text\n    axis.title = element_blank(),  # Remove axis titles\n    panel.grid = element_blank()\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/Maps-4.png){width=672}\n:::\n:::\n\n\n## Sensitivity Analysis: Results\n\nThe table below shows the results from our sensitivity analysis and follows a similar format to the previous table. Here, the statistics are broken up by variables used in the raking process and those that were not.\n\n![](rake_sensitivity_table.png)\n\nOverall, the results from the sensitivity analysis showed stability across the three groupings. Based on this, the team in Ghana decided which groupings of regions made the most sense based on knowledge of the regions, selecting 4a as their preferred model.\n\n# Bibliography:\n\nBattaglia, M., Izrael, D., Hoaglin, D., & Frankel, M. (2004a). Tips and Tricks for Raking Survey Data (aka Sample Balancing). Abt Associates.\n\nBattaglia, M. P., Hoaglin, D. C., & Frankel, M. R. (2009). Practical Considerations in Raking Survey Data. Survey Practice, 2(5). https://doi.org/10.29115/SP-2009-0019\n\nBrick, J. M., Montaquila, J., Roth, S., & Brick, J. M. (2003). IDENTIFYING PROBLEMS WITH RAKING ESTIMATORS.\n\nCalibrating Survey Data using Iterative Proportional Fitting (Raking). (n.d.).\nhttps://doi.org/10.1177/1536867X1401400104\n\nDeBell, M., & Krosnick, J. A. (n.d.). Computing Weights for American National Election Study Survey Data.\n\nKennedy, A. M., Arnold Lau and Courtney. (2018, January 26). 1. How different weighting methods work. Pew Research Center. https://www.pewresearch.org/methods/2018/01/26/how-different-weighting-methods-work/\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/htmlwidgets-1.6.1/htmlwidgets.js\"></script>\n<link href=\"../../site_libs/datatables-css-0.0.0/datatables-crosstalk.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/datatables-binding-0.27/datatables.js\"></script>\n<script src=\"../../site_libs/jquery-3.6.0/jquery-3.6.0.min.js\"></script>\n<link href=\"../../site_libs/dt-core-1.12.1/css/jquery.dataTables.min.css\" rel=\"stylesheet\" />\n<link href=\"../../site_libs/dt-core-1.12.1/css/jquery.dataTables.extra.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/dt-core-1.12.1/js/jquery.dataTables.min.js\"></script>\n<link href=\"../../site_libs/crosstalk-1.2.0/css/crosstalk.min.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/crosstalk-1.2.0/js/crosstalk.min.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}